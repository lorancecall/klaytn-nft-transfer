{"ast":null,"code":"require(\"core-js/modules/es.array.includes.js\");\n\n/*\n Modifications copyright 2018 The caver-js Authors\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n This file is derived from web3.js/packages/web3-providers-ws/src/index.js (2019/06/12).\n Modified and improved for the caver-js development.\n */\n\n/** @file WebsocketProvider.js\n * @authors:\n *   Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nconst EventEmitter = require('eventemitter3');\n\nconst Ws = require('websocket').w3cwebsocket;\n\nconst helpers = require('./helpers');\n\nconst errors = require('../../../caver-core-helpers').errors;\n/**\n * @param {string} url\n * @param {Object} options\n *\n * @constructor\n */\n\n\nconst WebsocketProvider = function WebsocketProvider(url, options) {\n  EventEmitter.call(this);\n  options = options || {};\n  this.url = url;\n  this._customTimeout = options.timeout || 1000 * 15;\n  this.headers = options.headers || {};\n  this.protocol = options.protocol || undefined;\n  this.reconnectOptions = {\n    auto: false,\n    delay: 5000,\n    maxAttempts: false,\n    onTimeout: false,\n    ...options.reconnect\n  };\n  this.clientConfig = options.clientConfig || undefined; // Allow a custom client configuration\n\n  this.requestOptions = options.requestOptions || undefined; // Allow a custom request options (https://github.com/theturtle32/WebSocket-Node/blob/master/docs/WebSocketClient.md#connectrequesturl-requestedprotocols-origin-headers-requestoptions)\n\n  this.DATA = 'data';\n  this.CLOSE = 'close';\n  this.ERROR = 'error';\n  this.CONNECT = 'connect';\n  this.RECONNECT = 'reconnect';\n  this.connection = null;\n  this.requestQueue = new Map();\n  this.responseQueue = new Map();\n  this.reconnectAttempts = 0;\n  this.reconnecting = false; // The w3cwebsocket implementation does not support Basic Auth\n  // username/password in the URL. So generate the basic auth header, and\n  // pass through with any additional headers supplied in constructor\n\n  const parsedURL = helpers.parseURL(url);\n\n  if (parsedURL.username && parsedURL.password) {\n    this.headers.authorization = `Basic ${helpers.btoa(`${parsedURL.username}:${parsedURL.password}`)}`;\n  } // When all node core implementations that do not have the\n  // WHATWG compatible URL parser go out of service this line can be removed.\n\n\n  if (parsedURL.auth) {\n    this.headers.authorization = `Basic ${helpers.btoa(parsedURL.auth)}`;\n  } // make property `connected` which will return the current connection status\n\n\n  Object.defineProperty(this, 'connected', {\n    get: function () {\n      return this.connection && this.connection.readyState === this.connection.OPEN;\n    },\n    enumerable: true\n  });\n  this.connect();\n}; // Inherit from EventEmitter\n\n\nWebsocketProvider.prototype = Object.create(EventEmitter.prototype);\nWebsocketProvider.prototype.constructor = WebsocketProvider;\n/**\n * Connects to the configured node\n *\n * @method connect\n *\n * @returns {void}\n */\n\nWebsocketProvider.prototype.connect = function () {\n  this.connection = new Ws(this.url, this.protocol, undefined, this.headers, this.requestOptions, this.clientConfig);\n\n  this._addSocketListeners();\n};\n/**\n * Listener for the `data` event of the underlying WebSocket object\n *\n * @method _onMessage\n *\n * @returns {void}\n */\n\n\nWebsocketProvider.prototype._onMessage = function (e) {\n  const _this = this;\n\n  this._parseResponse(typeof e.data === 'string' ? e.data : '').forEach(function (result) {\n    if (result.method && result.method.indexOf('_subscription') !== -1) {\n      _this.emit(_this.DATA, result);\n\n      return;\n    }\n\n    let id = result.id; // get the id which matches the returned id\n\n    if (Array.isArray(result)) {\n      id = result[0].id;\n    }\n\n    if (_this.responseQueue.has(id)) {\n      if (_this.responseQueue.get(id).callback !== undefined) {\n        _this.responseQueue.get(id).callback(false, result);\n      }\n\n      _this.responseQueue.delete(id);\n    }\n  });\n};\n/**\n * Listener for the `open` event of the underlying WebSocket object\n *\n * @method _onConnect\n *\n * @returns {void}\n */\n\n\nWebsocketProvider.prototype._onConnect = function () {\n  this.emit(this.CONNECT);\n  this.reconnectAttempts = 0;\n  this.reconnecting = false;\n\n  if (this.requestQueue.size > 0) {\n    const _this = this;\n\n    this.requestQueue.forEach(function (request, key) {\n      _this.send(request.payload, request.callback);\n\n      _this.requestQueue.delete(key);\n    });\n  }\n};\n/**\n * Listener for the `close` event of the underlying WebSocket object\n *\n * @method _onClose\n *\n * @returns {void}\n */\n\n\nWebsocketProvider.prototype._onClose = function (event) {\n  const _this = this;\n\n  if (this.reconnectOptions.auto && (![1000, 1001].includes(event.code) || event.wasClean === false)) {\n    this.reconnect();\n    return;\n  }\n\n  this.emit(this.CLOSE, event);\n\n  if (this.requestQueue.size > 0) {\n    this.requestQueue.forEach(function (request, key) {\n      request.callback(errors.ConnectionNotOpenError(event));\n\n      _this.requestQueue.delete(key);\n    });\n  }\n\n  if (this.responseQueue.size > 0) {\n    this.responseQueue.forEach(function (request, key) {\n      request.callback(errors.InvalidConnection('on WS', event));\n\n      _this.responseQueue.delete(key);\n    });\n  }\n\n  this._removeSocketListeners();\n\n  this.removeAllListeners();\n};\n/**\n * Will add the required socket listeners\n *\n * @method _addSocketListeners\n *\n * @returns {void}\n */\n\n\nWebsocketProvider.prototype._addSocketListeners = function () {\n  this.connection.addEventListener('message', this._onMessage.bind(this));\n  this.connection.addEventListener('open', this._onConnect.bind(this));\n  this.connection.addEventListener('close', this._onClose.bind(this));\n};\n/**\n * Will remove all socket listeners\n *\n * @method _removeSocketListeners\n *\n * @returns {void}\n */\n\n\nWebsocketProvider.prototype._removeSocketListeners = function () {\n  this.connection.removeEventListener('message', this._onMessage);\n  this.connection.removeEventListener('open', this._onConnect);\n  this.connection.removeEventListener('close', this._onClose);\n};\n/**\n * Will parse the response and make an array out of it.\n *\n * @method _parseResponse\n *\n * @param {String} data\n *\n * @returns {Array}\n */\n\n\nWebsocketProvider.prototype._parseResponse = function (data) {\n  const _this = this;\n\n  const returnValues = []; // DE-CHUNKER\n\n  const dechunkedData = data.replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n  .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n  .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n  .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n  .split('|--|');\n  dechunkedData.forEach(function (d) {\n    // prepend the last chunk\n    if (_this.lastChunk) d = _this.lastChunk + d;\n    let result = null;\n\n    try {\n      result = JSON.parse(d);\n    } catch (e) {\n      _this.lastChunk = d; // start timeout to cancel all requests\n\n      clearTimeout(_this.lastChunkTimeout);\n      _this.lastChunkTimeout = setTimeout(function () {\n        if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {\n          _this.reconnect();\n\n          return;\n        }\n\n        _this.emit(_this.ERROR, errors.ConnectionTimeout(_this._customTimeout));\n\n        if (_this.requestQueue.size > 0) {\n          _this.requestQueue.forEach(function (request, key) {\n            request.callback(errors.ConnectionTimeout(_this._customTimeout));\n\n            _this.requestQueue.delete(key);\n          });\n        }\n      }, _this._customTimeout);\n      return;\n    } // cancel timeout and set chunk to null\n\n\n    clearTimeout(_this.lastChunkTimeout);\n    _this.lastChunk = null;\n    if (result) returnValues.push(result);\n  });\n  return returnValues;\n};\n/**\n * Does check if the provider is connecting and will add it to the queue or will send it directly\n *\n * @method send\n *\n * @param {Object} payload\n * @param {Function} callback\n *\n * @returns {void}\n */\n\n\nWebsocketProvider.prototype.send = function (payload, callback) {\n  const _this = this;\n\n  let id = payload.id;\n  const request = {\n    payload: payload,\n    callback: callback\n  };\n\n  if (Array.isArray(payload)) {\n    id = payload[0].id;\n  }\n\n  if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {\n    this.requestQueue.set(id, request);\n    return;\n  }\n\n  if (this.connection.readyState !== this.connection.OPEN) {\n    this.requestQueue.delete(id);\n    this.emit(this.ERROR, errors.ConnectionNotOpenError());\n    request.callback(errors.ConnectionNotOpenError());\n    return;\n  }\n\n  this.responseQueue.set(id, request);\n  this.requestQueue.delete(id);\n\n  try {\n    this.connection.send(JSON.stringify(request.payload));\n  } catch (error) {\n    request.callback(error);\n\n    _this.responseQueue.delete(id);\n  }\n};\n/**\n * Resets the providers, clears all callbacks\n *\n * @method reset\n *\n * @returns {void}\n */\n\n\nWebsocketProvider.prototype.reset = function () {\n  this.responseQueue.clear();\n  this.requestQueue.clear();\n  this.removeAllListeners();\n\n  this._removeSocketListeners();\n\n  this._addSocketListeners();\n};\n/**\n * Closes the current connection with the given code and reason arguments\n *\n * @method disconnect\n *\n * @param {number} code\n * @param {string} reason\n *\n * @returns {void}\n */\n\n\nWebsocketProvider.prototype.disconnect = function (code, reason) {\n  this._removeSocketListeners();\n\n  this.connection.close(code || 1000, reason);\n};\n/**\n * Returns the desired boolean.\n *\n * @method supportsSubscriptions\n *\n * @returns {boolean}\n */\n\n\nWebsocketProvider.prototype.supportsSubscriptions = function () {\n  return true;\n};\n/**\n * Removes the listeners and reconnects to the socket.\n *\n * @method reconnect\n *\n * @returns {void}\n */\n\n\nWebsocketProvider.prototype.reconnect = function () {\n  const _this = this;\n\n  this.reconnecting = true;\n\n  if (this.responseQueue.size > 0) {\n    this.responseQueue.forEach(function (request, key) {\n      request.callback(errors.PendingRequestsOnReconnectingError());\n\n      _this.responseQueue.delete(key);\n    });\n  }\n\n  if (!this.reconnectOptions.maxAttempts || this.reconnectAttempts < this.reconnectOptions.maxAttempts) {\n    setTimeout(function () {\n      _this.reconnectAttempts++;\n\n      _this._removeSocketListeners();\n\n      _this.emit(_this.RECONNECT, _this.reconnectAttempts);\n\n      _this.connect();\n    }, this.reconnectOptions.delay);\n    return;\n  }\n\n  this.emit(this.ERROR, errors.MaxAttemptsReachedOnReconnectingError());\n  this.reconnecting = false;\n\n  if (this.requestQueue.size > 0) {\n    this.requestQueue.forEach(function (request, key) {\n      request.callback(errors.MaxAttemptsReachedOnReconnectingError());\n\n      _this.requestQueue.delete(key);\n    });\n  }\n};\n\nmodule.exports = WebsocketProvider;","map":{"version":3,"sources":["/home/lorancecall/Projects/vuejs-tutorial/testpage/node_modules/caver-js/packages/caver-core-requestmanager/caver-providers-ws/src/index.js"],"names":["EventEmitter","require","Ws","w3cwebsocket","helpers","errors","WebsocketProvider","url","options","call","_customTimeout","timeout","headers","protocol","undefined","reconnectOptions","auto","delay","maxAttempts","onTimeout","reconnect","clientConfig","requestOptions","DATA","CLOSE","ERROR","CONNECT","RECONNECT","connection","requestQueue","Map","responseQueue","reconnectAttempts","reconnecting","parsedURL","parseURL","username","password","authorization","btoa","auth","Object","defineProperty","get","readyState","OPEN","enumerable","connect","prototype","create","constructor","_addSocketListeners","_onMessage","e","_this","_parseResponse","data","forEach","result","method","indexOf","emit","id","Array","isArray","has","callback","delete","_onConnect","size","request","key","send","payload","_onClose","event","includes","code","wasClean","ConnectionNotOpenError","InvalidConnection","_removeSocketListeners","removeAllListeners","addEventListener","bind","removeEventListener","returnValues","dechunkedData","replace","split","d","lastChunk","JSON","parse","clearTimeout","lastChunkTimeout","setTimeout","ConnectionTimeout","push","CONNECTING","set","stringify","error","reset","clear","disconnect","reason","close","supportsSubscriptions","PendingRequestsOnReconnectingError","MaxAttemptsReachedOnReconnectingError","module","exports"],"mappings":"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","sourcesContent":["/*\n Modifications copyright 2018 The caver-js Authors\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n This file is derived from web3.js/packages/web3-providers-ws/src/index.js (2019/06/12).\n Modified and improved for the caver-js development.\n */\n/** @file WebsocketProvider.js\n * @authors:\n *   Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\n\nconst EventEmitter = require('eventemitter3')\nconst Ws = require('websocket').w3cwebsocket\nconst helpers = require('./helpers')\nconst errors = require('../../../caver-core-helpers').errors\n\n/**\n * @param {string} url\n * @param {Object} options\n *\n * @constructor\n */\nconst WebsocketProvider = function WebsocketProvider(url, options) {\n    EventEmitter.call(this)\n\n    options = options || {}\n    this.url = url\n    this._customTimeout = options.timeout || 1000 * 15\n    this.headers = options.headers || {}\n    this.protocol = options.protocol || undefined\n    this.reconnectOptions = {\n        auto: false,\n        delay: 5000,\n        maxAttempts: false,\n        onTimeout: false,\n        ...options.reconnect,\n    }\n    this.clientConfig = options.clientConfig || undefined // Allow a custom client configuration\n    this.requestOptions = options.requestOptions || undefined // Allow a custom request options (https://github.com/theturtle32/WebSocket-Node/blob/master/docs/WebSocketClient.md#connectrequesturl-requestedprotocols-origin-headers-requestoptions)\n\n    this.DATA = 'data'\n    this.CLOSE = 'close'\n    this.ERROR = 'error'\n    this.CONNECT = 'connect'\n    this.RECONNECT = 'reconnect'\n\n    this.connection = null\n    this.requestQueue = new Map()\n    this.responseQueue = new Map()\n    this.reconnectAttempts = 0\n    this.reconnecting = false\n\n    // The w3cwebsocket implementation does not support Basic Auth\n    // username/password in the URL. So generate the basic auth header, and\n    // pass through with any additional headers supplied in constructor\n    const parsedURL = helpers.parseURL(url)\n    if (parsedURL.username && parsedURL.password) {\n        this.headers.authorization = `Basic ${helpers.btoa(`${parsedURL.username}:${parsedURL.password}`)}`\n    }\n\n    // When all node core implementations that do not have the\n    // WHATWG compatible URL parser go out of service this line can be removed.\n    if (parsedURL.auth) {\n        this.headers.authorization = `Basic ${helpers.btoa(parsedURL.auth)}`\n    }\n\n    // make property `connected` which will return the current connection status\n    Object.defineProperty(this, 'connected', {\n        get: function() {\n            return this.connection && this.connection.readyState === this.connection.OPEN\n        },\n        enumerable: true,\n    })\n\n    this.connect()\n}\n\n// Inherit from EventEmitter\nWebsocketProvider.prototype = Object.create(EventEmitter.prototype)\nWebsocketProvider.prototype.constructor = WebsocketProvider\n\n/**\n * Connects to the configured node\n *\n * @method connect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.connect = function() {\n    this.connection = new Ws(this.url, this.protocol, undefined, this.headers, this.requestOptions, this.clientConfig)\n    this._addSocketListeners()\n}\n\n/**\n * Listener for the `data` event of the underlying WebSocket object\n *\n * @method _onMessage\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onMessage = function(e) {\n    const _this = this\n\n    this._parseResponse(typeof e.data === 'string' ? e.data : '').forEach(function(result) {\n        if (result.method && result.method.indexOf('_subscription') !== -1) {\n            _this.emit(_this.DATA, result)\n\n            return\n        }\n\n        let id = result.id\n\n        // get the id which matches the returned id\n        if (Array.isArray(result)) {\n            id = result[0].id\n        }\n\n        if (_this.responseQueue.has(id)) {\n            if (_this.responseQueue.get(id).callback !== undefined) {\n                _this.responseQueue.get(id).callback(false, result)\n            }\n            _this.responseQueue.delete(id)\n        }\n    })\n}\n\n/**\n * Listener for the `open` event of the underlying WebSocket object\n *\n * @method _onConnect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onConnect = function() {\n    this.emit(this.CONNECT)\n    this.reconnectAttempts = 0\n    this.reconnecting = false\n\n    if (this.requestQueue.size > 0) {\n        const _this = this\n\n        this.requestQueue.forEach(function(request, key) {\n            _this.send(request.payload, request.callback)\n            _this.requestQueue.delete(key)\n        })\n    }\n}\n\n/**\n * Listener for the `close` event of the underlying WebSocket object\n *\n * @method _onClose\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._onClose = function(event) {\n    const _this = this\n\n    if (this.reconnectOptions.auto && (![1000, 1001].includes(event.code) || event.wasClean === false)) {\n        this.reconnect()\n\n        return\n    }\n\n    this.emit(this.CLOSE, event)\n\n    if (this.requestQueue.size > 0) {\n        this.requestQueue.forEach(function(request, key) {\n            request.callback(errors.ConnectionNotOpenError(event))\n            _this.requestQueue.delete(key)\n        })\n    }\n\n    if (this.responseQueue.size > 0) {\n        this.responseQueue.forEach(function(request, key) {\n            request.callback(errors.InvalidConnection('on WS', event))\n            _this.responseQueue.delete(key)\n        })\n    }\n\n    this._removeSocketListeners()\n    this.removeAllListeners()\n}\n\n/**\n * Will add the required socket listeners\n *\n * @method _addSocketListeners\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._addSocketListeners = function() {\n    this.connection.addEventListener('message', this._onMessage.bind(this))\n    this.connection.addEventListener('open', this._onConnect.bind(this))\n    this.connection.addEventListener('close', this._onClose.bind(this))\n}\n\n/**\n * Will remove all socket listeners\n *\n * @method _removeSocketListeners\n *\n * @returns {void}\n */\nWebsocketProvider.prototype._removeSocketListeners = function() {\n    this.connection.removeEventListener('message', this._onMessage)\n    this.connection.removeEventListener('open', this._onConnect)\n    this.connection.removeEventListener('close', this._onClose)\n}\n\n/**\n * Will parse the response and make an array out of it.\n *\n * @method _parseResponse\n *\n * @param {String} data\n *\n * @returns {Array}\n */\nWebsocketProvider.prototype._parseResponse = function(data) {\n    const _this = this\n    const returnValues = []\n\n    // DE-CHUNKER\n    const dechunkedData = data\n        .replace(/\\}[\\n\\r]?\\{/g, '}|--|{') // }{\n        .replace(/\\}\\][\\n\\r]?\\[\\{/g, '}]|--|[{') // }][{\n        .replace(/\\}[\\n\\r]?\\[\\{/g, '}|--|[{') // }[{\n        .replace(/\\}\\][\\n\\r]?\\{/g, '}]|--|{') // }]{\n        .split('|--|')\n\n    dechunkedData.forEach(function(d) {\n        // prepend the last chunk\n        if (_this.lastChunk) d = _this.lastChunk + d\n\n        let result = null\n\n        try {\n            result = JSON.parse(d)\n        } catch (e) {\n            _this.lastChunk = d\n\n            // start timeout to cancel all requests\n            clearTimeout(_this.lastChunkTimeout)\n            _this.lastChunkTimeout = setTimeout(function() {\n                if (_this.reconnectOptions.auto && _this.reconnectOptions.onTimeout) {\n                    _this.reconnect()\n\n                    return\n                }\n\n                _this.emit(_this.ERROR, errors.ConnectionTimeout(_this._customTimeout))\n\n                if (_this.requestQueue.size > 0) {\n                    _this.requestQueue.forEach(function(request, key) {\n                        request.callback(errors.ConnectionTimeout(_this._customTimeout))\n                        _this.requestQueue.delete(key)\n                    })\n                }\n            }, _this._customTimeout)\n\n            return\n        }\n\n        // cancel timeout and set chunk to null\n        clearTimeout(_this.lastChunkTimeout)\n        _this.lastChunk = null\n\n        if (result) returnValues.push(result)\n    })\n\n    return returnValues\n}\n\n/**\n * Does check if the provider is connecting and will add it to the queue or will send it directly\n *\n * @method send\n *\n * @param {Object} payload\n * @param {Function} callback\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.send = function(payload, callback) {\n    const _this = this\n    let id = payload.id\n    const request = { payload: payload, callback: callback }\n\n    if (Array.isArray(payload)) {\n        id = payload[0].id\n    }\n\n    if (this.connection.readyState === this.connection.CONNECTING || this.reconnecting) {\n        this.requestQueue.set(id, request)\n\n        return\n    }\n\n    if (this.connection.readyState !== this.connection.OPEN) {\n        this.requestQueue.delete(id)\n\n        this.emit(this.ERROR, errors.ConnectionNotOpenError())\n        request.callback(errors.ConnectionNotOpenError())\n\n        return\n    }\n\n    this.responseQueue.set(id, request)\n    this.requestQueue.delete(id)\n\n    try {\n        this.connection.send(JSON.stringify(request.payload))\n    } catch (error) {\n        request.callback(error)\n        _this.responseQueue.delete(id)\n    }\n}\n\n/**\n * Resets the providers, clears all callbacks\n *\n * @method reset\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.reset = function() {\n    this.responseQueue.clear()\n    this.requestQueue.clear()\n\n    this.removeAllListeners()\n\n    this._removeSocketListeners()\n    this._addSocketListeners()\n}\n\n/**\n * Closes the current connection with the given code and reason arguments\n *\n * @method disconnect\n *\n * @param {number} code\n * @param {string} reason\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.disconnect = function(code, reason) {\n    this._removeSocketListeners()\n    this.connection.close(code || 1000, reason)\n}\n\n/**\n * Returns the desired boolean.\n *\n * @method supportsSubscriptions\n *\n * @returns {boolean}\n */\nWebsocketProvider.prototype.supportsSubscriptions = function() {\n    return true\n}\n\n/**\n * Removes the listeners and reconnects to the socket.\n *\n * @method reconnect\n *\n * @returns {void}\n */\nWebsocketProvider.prototype.reconnect = function() {\n    const _this = this\n    this.reconnecting = true\n\n    if (this.responseQueue.size > 0) {\n        this.responseQueue.forEach(function(request, key) {\n            request.callback(errors.PendingRequestsOnReconnectingError())\n            _this.responseQueue.delete(key)\n        })\n    }\n\n    if (!this.reconnectOptions.maxAttempts || this.reconnectAttempts < this.reconnectOptions.maxAttempts) {\n        setTimeout(function() {\n            _this.reconnectAttempts++\n            _this._removeSocketListeners()\n            _this.emit(_this.RECONNECT, _this.reconnectAttempts)\n            _this.connect()\n        }, this.reconnectOptions.delay)\n\n        return\n    }\n\n    this.emit(this.ERROR, errors.MaxAttemptsReachedOnReconnectingError())\n    this.reconnecting = false\n\n    if (this.requestQueue.size > 0) {\n        this.requestQueue.forEach(function(request, key) {\n            request.callback(errors.MaxAttemptsReachedOnReconnectingError())\n            _this.requestQueue.delete(key)\n        })\n    }\n}\n\nmodule.exports = WebsocketProvider\n"]},"metadata":{},"sourceType":"script"}