{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\nrequire(\"core-js/modules/es.array.includes.js\");\n\n/*\n    Copyright 2021 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst _ = require('lodash');\n\nconst BigNumber = require('bignumber.js');\n\nconst Contract = require('../../caver-contract');\n\nconst {\n  kip37JsonInterface,\n  kip37ByteCode,\n  determineSendParams,\n  formatParamForUint256,\n  validateDeployParameterForKIP37,\n  interfaceIds\n} = require('./kctHelper');\n\nconst {\n  isAddress,\n  toBuffer,\n  isHexStrict,\n  toHex,\n  stripHexPrefix,\n  leftPad\n} = require('../../caver-utils');\n\nconst KIP13 = require('./kip13');\n/**\n * The KIP37 class that helps you easily handle a smart contract that implements KIP-37 as a JavaScript object on the Klaytn blockchain platform (Klaytn).\n * @hideconstructor\n * @class\n */\n\n\nclass KIP37 extends Contract {\n  /**\n   * Creates a new KIP37 instance with its bound methods and events.\n   *\n   * @example\n   * const kip37 = caver.kct.kip37.create('0x{address in hex}')\n   *\n   * @param {string} tokenAddress - The KIP-37 token contract address.\n   * @param {Array} [abi] - The Contract Application Binary Interface (ABI) of the KIP-37.\n   * @return {KIP37}\n   */\n  static create(tokenAddress, abi) {\n    return new KIP37(tokenAddress, abi);\n  }\n  /**\n   * An object that defines the parameters required to deploy the KIP-37 contract.\n   *\n   * @typedef {object} KIP37.KIP37DeployParams\n   * @property {string} uri - The URI for all token types, by relying on the {@link http://kips.klaytn.com/KIPs/kip-37#metadata|token type ID substitution mechanism}.\n   */\n\n  /**\n   * Deploys a KIP-37 token contract to Klaytn network.\n   *\n   * By default, it returns a KIP37 instance when the deployment is finished.\n   * If you define a custom function in the `contractDeployFormatter` field in {@link Contract.SendOptions|SendOptions}, you can control return type.\n   *\n   * @example\n   * const tokenInfo = { uri: 'uri string' }\n   *\n   * // Below example will use `caver.wallet`.\n   * const deployed = await caver.kct.kip37.deploy(tokenInfo, '0x{deployer address}')\n   *\n   * // Use sendOptions instead of deployer address.\n   * const sendOptions = { from: '0x{deployer address}', feeDelegation: true, feePayer: '0x{fee payer address}' }\n   * const deployed = await caver.kct.kip37.deploy(tokenInfo, sendOptions)\n   *\n   * // If you want to use your own wallet that implements the 'IWallet' interface, pass it into the last parameter.\n   * const deployed = await caver.kct.kip37.deploy(tokenInfo, '0x{deployer address}', wallet)\n   *\n   * @param {KIP37.KIP37DeployParams} tokenInfo The object that defines the uri to deploy.\n   * @param {Contract.SendOptions|string} sendOptions An object holding parameters that are required for sending a transaction.\n   * @param {IWallet} [wallet] The wallet instance to sign and send a transaction.\n   * @return {Promise<*>}\n   */\n\n\n  static deploy(tokenInfo, sendOptions, wallet) {\n    validateDeployParameterForKIP37(tokenInfo);\n    const {\n      uri\n    } = tokenInfo;\n    const kip37 = new KIP37();\n    if (wallet !== undefined) kip37.setWallet(wallet); // If sendOptions is string type, sendOptions means deployer's address\n\n    if (_.isString(sendOptions)) sendOptions = {\n      from: sendOptions,\n      gas: 7000000,\n      value: 0\n    };\n    sendOptions.gas = sendOptions.gas !== undefined ? sendOptions.gas : 7000000;\n    return kip37.deploy({\n      data: kip37ByteCode,\n      arguments: [uri]\n    }).send(sendOptions);\n  }\n  /**\n   * An object that defines the parameters required to deploy the KIP-37 contract.\n   *\n   * @typedef {object} KIP37.KIP37DetectedObject\n   * @property {boolean} IKIP37 - Whether to implement `IKIP37` interface.\n   * @property {boolean} IKIP37Metadata - Whether to implement `IKIP37Metadata` interface.\n   * @property {boolean} IKIP37Mintable - Whether to implement `IKIP37Mintable` interface.\n   * @property {boolean} IKIP37Burnable - Whether to implement `IKIP37Burnable` interface.\n   * @property {boolean} IKIP37Pausable - Whether to implement `IKIP37Pausable` interface.\n   */\n\n  /**\n   * Returns the information of the interface implemented by the token contract.\n   *\n   * @example\n   * const detected = await caver.kct.kip37.detectInterface('0x{address in hex}')\n   *\n   * @param {string} contractAddress The address of the KIP-37 token contract to detect.\n   * @return {Promise<KIP37.KIP37DetectedObject>}\n   */\n\n\n  static detectInterface(contractAddress) {\n    const kip37 = new KIP37(contractAddress);\n    return kip37.detectInterface();\n  }\n\n  constructor(tokenAddress, abi = kip37JsonInterface) {\n    if (tokenAddress) {\n      if (_.isString(tokenAddress)) {\n        if (!isAddress(tokenAddress)) throw new Error(`Invalid token address ${tokenAddress}`);\n      } else {\n        abi = tokenAddress;\n        tokenAddress = undefined;\n      }\n    }\n\n    super(abi, tokenAddress);\n    this.setWallet(KIP37.wallet);\n  }\n  /**\n   * Clones the current KIP37 instance.\n   *\n   * @example\n   * const cloned = kip37.clone()\n   * const cloned = kip37.clone('0x{new kip7 address}')\n   *\n   * @param {string} [tokenAddress] The address of the token contract.\n   * @return {KIP37}\n   */\n\n\n  clone(tokenAddress = this.options.address) {\n    const cloned = new this.constructor(tokenAddress, this.options.jsonInterface);\n    cloned.setWallet(this._wallet);\n    return cloned;\n  }\n  /**\n   * Returns the information of the interface implemented by the token contract.\n   *\n   * @example\n   * const detected = await kip37.detectInterface()\n   *\n   * @return {Promise<KIP37.KIP37DetectedObject>}\n   */\n\n\n  async detectInterface() {\n    const detected = {\n      IKIP37: false,\n      IKIP37Metadata: false,\n      IKIP37Mintable: false,\n      IKIP37Burnable: false,\n      IKIP37Pausable: false\n    };\n    const notSupportedMsg = `This contract does not support KIP-13.`;\n    const contractAddress = this._address;\n\n    try {\n      const isSupported = await KIP13.isImplementedKIP13Interface(contractAddress);\n      if (isSupported !== true) throw new Error(notSupportedMsg); // Since there is an extension that has the same interface id even though it is a different KCT,\n      // it must be checked first whether the contract is a KIP-37 contract.\n\n      detected.IKIP37 = await this.supportsInterface(interfaceIds.kip37.IKIP37);\n      if (detected.IKIP37 === false) return detected;\n      await Promise.all(Object.keys(interfaceIds.kip37).map(async interfaceName => {\n        if (interfaceIds.kip37[interfaceName] !== interfaceIds.kip37.IKIP37) detected[interfaceName] = await this.supportsInterface(interfaceIds.kip37[interfaceName]);\n      }));\n      return detected;\n    } catch (e) {\n      throw new Error(notSupportedMsg);\n    }\n  }\n  /**\n   * Returns `true` if this contract implements the interface defined by `interfaceId`.\n   *\n   * @example\n   * const supported = await kip37.supportsInterface('0x6433ca1f')\n   *\n   * @param {string} interfaceId The interface id to check.\n   * @return {Promise<boolean>}\n   */\n\n\n  async supportsInterface(interfaceId) {\n    const isSupported = await this.methods.supportsInterface(interfaceId).call();\n    return isSupported;\n  }\n  /**\n   * Returns distinct Uniform Resource Identifier (URI) of the given token.\n   * If the string {id} exists in any URI, this function will replace this with the actual token ID in hexadecimal form.\n   * Please refer to {@link http://kips.klaytn.com/KIPs/kip-37#metadata|KIP-34 Metadata}.\n   *\n   * @example\n   * const uri = await kip37.uri('0x0')\n   *\n   * @param {BigNumber|string|number} id The token id to get uri.\n   * @return {Promise<string>}\n   */\n\n\n  async uri(id) {\n    let uri = await this.methods.uri(formatParamForUint256(id)).call(); // Replace {id} to token id in hexadecimal form.\n\n    if (uri.includes('{id}')) {\n      let tokenIdInHex = stripHexPrefix(toHex(id));\n      tokenIdInHex = leftPad(tokenIdInHex, 64, '0');\n      uri = uri.replace('{id}', tokenIdInHex);\n    }\n\n    return uri;\n  }\n  /**\n   * Returns the total token supply of the specific token.\n   *\n   * @example\n   * const totalSupply = await kip37.totalSupply(0)\n   *\n   * @param {BigNumber|string|number} id The token id to see the total supply.\n   * @return {Promise<BigNumber>}\n   */\n\n\n  async totalSupply(id) {\n    const totalSupply = await this.methods.totalSupply(formatParamForUint256(id)).call();\n    return new BigNumber(totalSupply);\n  }\n  /**\n   * Returns the amount of tokens of token type `id` owned by `account`.\n   *\n   * @example\n   * const balance = await kip37.balanceOf('0x{address in hex}', 0)\n   *\n   * @param {string} account The address of the account for which you want to see balance.\n   * @param {BigNumber|string|number} id The token id to see balance.\n   * @return {Promise<BigNumber>}\n   */\n\n\n  async balanceOf(account, id) {\n    const balance = await this.methods.balanceOf(account, formatParamForUint256(id)).call();\n    return new BigNumber(balance);\n  }\n  /**\n   * Returns the balance of multiple account/token pairs.\n   * `balanceOfBatch` is a batch operation of {@link balanceOf}, and the length of arrays with `accounts` and `ids` must be the same.\n   *\n   * @param {Array.<string>} accounts The address of the accounts for which you want to see balance.\n   * @param {Array.<BigNumber|string|number>} ids An array of ids of token you want to see balance.\n   * @return {Promise<Array.<BigNumber>>}\n   */\n\n\n  async balanceOfBatch(accounts, ids) {\n    if (ids.length !== accounts.length) throw new Error(`ids and accounts must have the same length.`);\n    const formattedTokenIds = [];\n\n    for (let i = 0; i < ids.length; i++) {\n      formattedTokenIds.push(formatParamForUint256(ids[i]));\n    }\n\n    const balances = await this.methods.balanceOfBatch(accounts, formattedTokenIds).call();\n    const ret = [];\n\n    for (const bal of balances) {\n      ret.push(new BigNumber(bal));\n    }\n\n    return ret;\n  }\n  /**\n   * Queries the approval status of an operator for a given owner. Returns true if an operator is approved by a given owner.\n   *\n   * @example\n   * const isApprovedForAll = await kip37.isApprovedForAll('0x{address in hex}', '0x{address in hex}')\n   *\n   * @param {string} owner The address of the owner.\n   * @param {string} operator The address of the operator.\n   * @return {Promise<boolean>}\n   */\n\n\n  async isApprovedForAll(owner, operator) {\n    const isApprovedForAll = await this.methods.isApprovedForAll(owner, operator).call();\n    return isApprovedForAll;\n  }\n  /**\n   * Returns whether or not the token contract's transaction (or specific token) is paused.\n   *\n   * If `id` parameter is not defined, return whether the token contract's transaction is paused.\n   * If `id` parameter is defined, return whether the specific token is paused.\n   *\n   * @example\n   * // without token id parameter\n   * const isPaused = await kip37.paused()\n   * // with token id parameter\n   * const isPaused = await kip37.paused(0)\n   *\n   * @param {BigNumber|string|number} [id] The token id to check wether paused or not. If this parameter is omitted, the `paused` function return whether the contract is in paused state.\n   * @return {Promise<boolean>}\n   */\n\n\n  async paused(id) {\n    const callObject = id !== undefined ? this.methods.paused(formatParamForUint256(id)) : this.methods.paused();\n    const isPaused = await callObject.call();\n    return isPaused;\n  }\n  /**\n   * Returns `true` if the given account is a pauser who can suspend transferring tokens.\n   *\n   * @example\n   * const isPauser = await kip37.isPauser('0x{address in hex}')\n   *\n   * @param {string} account The address of the account to be checked for having the right to suspend transferring tokens.\n   * @return {Promise<boolean>}\n   */\n\n\n  async isPauser(account) {\n    const isPauser = await this.methods.isPauser(account).call();\n    return isPauser;\n  }\n  /**\n   * Returns `true` if the given account is a minter who can issue new KIP37 tokens.\n   *\n   * @example\n   * const isMinter = await kip37.isMinter('0x{address in hex}')\n   *\n   * @param {string} account The address of the account to be checked for having the minting right.\n   * @return {Promise<boolean>}\n   */\n\n\n  async isMinter(account) {\n    const isMinter = await this.methods.isMinter(account).call();\n    return isMinter;\n  }\n  /**\n   * create creates token and assigns them to account, increasing the total supply.\n   *\n   * @example\n   * // Send via a sendParam object with the from field given\n   * const receipt = await kip37.create(2, '1000000000000000000', { from: '0x{address in hex}' })\n   *\n   * @param {BigNumber|string|number} id The token id to create.\n   * @param {BigNumber|string|number} initialSupply The amount of tokens being minted.\n   * @param {string} [uri] The token URI of the created token.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async create(id, initialSupply, uri, sendParam = {}) {\n    if (uri && _.isObject(uri)) {\n      if (uri.gas !== undefined || uri.from !== undefined) {\n        if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`);\n        sendParam = uri;\n        uri = '';\n      }\n    }\n\n    const executableObj = this.methods.create(formatParamForUint256(id), formatParamForUint256(initialSupply), uri);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Approves the given operator, or disallow the given operator, to transfer all tokens of the owner.\n   * An operator is allowed to transfer all tokens of the sender on their behalf.\n   *\n   * @example\n   * const receipt = await kip37.setApprovalForAll('0x{address in hex}', true, { from: '0x{address in hex}' })\n   *\n   * @param {string} operator The address of an account to be approved/prohibited to transfer the owner's all tokens.\n   * @param {boolean} approved This operator will be approved if `true`. The operator will be disallowed if `false`.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async setApprovalForAll(operator, approved, sendParam = {}) {\n    const executableObj = this.methods.setApprovalForAll(operator, approved);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Safely transfers the given `amount` tokens of specific token type `id` from `from` to the `recipient`.\n   *\n   * The address who was approved to send the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n   * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n   * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n   *\n   * If the `recipient` was a contract address, it should implement `IKIP37Receiver.onKIP37Received`. Otherwise, the transfer is reverted.\n   *\n   * @example\n   * const receipt = await kip37.safeTransferFrom('0x{address in hex}', '0x{address in hex}', 2, 10000, { from: '0x{address in hex}' })\n   *\n   * @param {string} from The address of the account that owns the token to be sent with allowance mechanism.\n   * @param {string} to The address of the account to receive the token.\n   * @param {BigNumber|string|number} id The token id to transfer.\n   * @param {BigNumber|string|number} amount The amount of token you want to transfer.\n   * @param {Buffer|string|number} [data] (optional) The data to send along with the call.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async safeTransferFrom(from, to, id, amount, data, sendParam = {}) {\n    if (data && _.isObject(data)) {\n      if (data.gas !== undefined || data.from !== undefined) {\n        if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`);\n        sendParam = data;\n        data = Buffer.from('');\n      }\n    }\n\n    if (data && !_.isBuffer(data)) {\n      if (_.isString(data) && !isHexStrict(data)) data = toHex(data);\n      data = toBuffer(data);\n    }\n\n    const executableObj = this.methods.safeTransferFrom(from, to, formatParamForUint256(id), formatParamForUint256(amount), data);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Safely batch transfers of multiple token ids and values from `from` to the `recipient`.\n   *\n   * The address who was approved to send the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n   * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n   * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n   *\n   * If the `recipient` was a contract address, it should implement `IKIP37Receiver.onKIP37Received`. Otherwise, the transfer is reverted.\n   *\n   * @example\n   * const receipt = await kip37.safeBatchTransferFrom('0x{address in hex}', '0x{address in hex}', [1, 2], [10, 1000], { from: '0x{address in hex}' })\n   *\n   * @param {string} from The address of the account that owns the token to be sent with allowance mechanism.\n   * @param {string} recipient The address of the account to receive the token.\n   * @param {Array.<BigNumber|string|number>} ids An array of the token ids to transfer.\n   * @param {Array.<BigNumber|string|number>} amounts An array of the token amounts you want to transfer.\n   * @param {Buffer|string|number} [data] (optional) The data to send along with the call.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async safeBatchTransferFrom(from, recipient, ids, amounts, data, sendParam = {}) {\n    if (data && _.isObject(data)) {\n      if (data.gas !== undefined || data.from !== undefined) {\n        if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`);\n        sendParam = data;\n        data = Buffer.from('');\n      }\n    }\n\n    if (data && !_.isBuffer(data)) {\n      if (_.isString(data) && !isHexStrict(data)) data = toHex(data);\n      data = toBuffer(data);\n    }\n\n    if (ids.length !== amounts.length) throw new Error(`ids and amounts must have the same length.`);\n    const formattedTokenIds = [];\n    const formattedTokenAmounts = [];\n\n    for (let i = 0; i < ids.length; i++) {\n      formattedTokenIds.push(formatParamForUint256(ids[i]));\n      formattedTokenAmounts.push(formatParamForUint256(amounts[i]));\n    }\n\n    const executableObj = this.methods.safeBatchTransferFrom(from, recipient, formattedTokenIds, formattedTokenAmounts, data);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Mints the token of the specific token type `id` and assigns the tokens according to the variables `to` and `value`.\n   * The mint function allows you to mint specific token to multiple accounts at once by passing arrays `to` to and `value` as parameters.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n   *\n   * @example\n   * const receipt = await kip37.mint('0x{address in hex}', 2, 1000, { from: '0x{address in hex}' })\n   *\n   * @param {string|Array.<string>} toList An address of the account or an array of addresses to which the minted token will be issued.\n   * @param {BigNumber|string|number} id The token id to mint.\n   * @param {BigNumber|string|number|Array.<BigNumber|string|number>} values The amount of token to be minted. If an array containing multiple addresses is delivered to `to` parameter, the value must be delivered in the form of an array.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async mint(toList, id, values, sendParam = {}) {\n    if (_.isArray(toList) !== _.isArray(values)) throw new Error(`If you want to minting a specific token to multiple accounts, both toList and values both must be arrays.`);\n    let executableObj;\n\n    if (_.isArray(toList)) {\n      if (toList.length !== values.length) throw new Error(`toList and values must have the same length.`);\n      const formattedTokenValues = [];\n\n      for (const val of values) {\n        formattedTokenValues.push(formatParamForUint256(val));\n      }\n\n      executableObj = this.methods.mint(formatParamForUint256(id), toList, formattedTokenValues);\n    } else {\n      executableObj = this.methods.mint(formatParamForUint256(id), toList, formatParamForUint256(values));\n    }\n\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Mints the multiple KIP-37 tokens of the specific token types `ids` in a batch and assigns the tokens according to the variables `to` and `values`.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n   *\n   * @example\n   * const receipt = await kip37.mintBatch('0x{address in hex}', [1, 2], [100, 200], { from: '0x{address in hex}' })\n   *\n   * @param {string} to An address of the account to which the minted tokens will be issued.\n   * @param {Array.<BigNumber|string|number>} ids An array of the token ids to mint.\n   * @param {Array.<BigNumber|string|number>} values An array of the token amounts to mint.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async mintBatch(to, ids, values, sendParam = {}) {\n    if (ids.length !== values.length) throw new Error(`ids and values must have the same length.`);\n    const formattedTokenIds = [];\n    const formattedTokenValues = [];\n\n    for (let i = 0; i < ids.length; i++) {\n      formattedTokenIds.push(formatParamForUint256(ids[i]));\n      formattedTokenValues.push(formatParamForUint256(values[i]));\n    }\n\n    const executableObj = this.methods.mintBatch(to, formattedTokenIds, formattedTokenValues);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Adds an account as a minter, who are permitted to mint tokens.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n   *\n   * @example\n   * const receipt = await kip37.addMinter('0x{address in hex}', { from: '0x{address in hex}' })\n   *\n   * @param {string} account The address of the account to be added as a minter.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async addMinter(account, sendParam = {}) {\n    const executableObj = this.methods.addMinter(account);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Renounces the right to mint tokens. Only a minter address can renounce the minting right.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n   *\n   * @example\n   * const receipt = await kip37.renounceMinter({ from: '0x{address in hex}' })\n   *\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async renounceMinter(sendParam = {}) {\n    const executableObj = this.methods.renounceMinter();\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Burns specific KIP-37 tokens.\n   *\n   * The address who was approved to operate the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n   * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n   * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n   *\n   * @example\n   * const receipt = await kip37.burn('0x{address in hex}', 2, 10, { from: '0x{address in hex}' })\n   *\n   * @param {string} account The address of the account that owns the token to be destroyed.\n   * @param {BigNumber|string|number} id The id of token to be destroyed.\n   * @param {BigNumber|string|number} value The amount of token to be destroyed.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-7 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-7 abi.\n   */\n\n\n  async burn(account, id, value, sendParam = {}) {\n    const executableObj = this.methods.burn(account, formatParamForUint256(id), formatParamForUint256(value));\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Burns the multiple KIP-37 tokens.\n   *\n   * The address who was approved to operate the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n   * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n   * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n   *\n   * @example\n   * const receipt = await kip37.burnBatch('0x{address in hex}', [1, 2], [100, 200], { from: '0x{address in hex}' })\n   *\n   * @param {string} account The address of the account that owns the token to be destroyed.\n   * @param {Array.<BigNumber|string|number>} ids An array of the token ids to burn.\n   * @param {Array.<BigNumber|string|number>} values An array of the token amounts to burn.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async burnBatch(account, ids, values, sendParam = {}) {\n    if (ids.length !== values.length) throw new Error(`ids and values must have the same length.`);\n    const formattedTokenIds = [];\n    const formattedTokenValues = [];\n\n    for (let i = 0; i < ids.length; i++) {\n      formattedTokenIds.push(formatParamForUint256(ids[i]));\n      formattedTokenValues.push(formatParamForUint256(values[i]));\n    }\n\n    const executableObj = this.methods.burnBatch(account, formattedTokenIds, formattedTokenValues);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Suspends functions related to token operation.\n   * If `id` parameter is defined, pause the specific token. Otherwise pause the token contract.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n   *\n   * @example\n   * const receipt = await kip37.pause({ from: '0x{address in hex}' })\n   *\n   * @param {BigNumber|string|number} [id] The token id to pause. If this parameter is omitted, the `pause` function pause the token contract.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async pause(id, sendParam = {}) {\n    if (Object.keys(sendParam).length === 0 && _.isObject(id)) {\n      sendParam = id;\n      id = undefined;\n    }\n\n    const executableObj = id !== undefined ? this.methods.pause(formatParamForUint256(id)) : this.methods.pause();\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Resumes the paused contract or specific token.\n   * If `id` parameter is defined, unpause the specific token. Otherwise unpause the token contract.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n   *\n   * @example\n   * const receipt = await kip37.unpause({ from: '0x{address in hex}' })\n   *\n   * @param {BigNumber|string|number} [id] The token id to unpause. If this parameter is omitted, the `unpause` function unpause the token contract.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async unpause(id, sendParam = {}) {\n    if (Object.keys(sendParam).length === 0 && _.isObject(id)) {\n      sendParam = id;\n      id = undefined;\n    }\n\n    const executableObj = id !== undefined ? this.methods.unpause(formatParamForUint256(id)) : this.methods.unpause();\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Adds an account as a pauser that has the right to suspend the contract.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n   *\n   * @example\n   * const receipt = await kip37.addPauser('0x{address in hex}', { from: '0x{address in hex}' })\n   *\n   * @param {string} account The address of the account to be a new pauser.\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async addPauser(account, sendParam = {}) {\n    const executableObj = this.methods.addPauser(account);\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n  /**\n   * Renounces the right to pause the contract. Only a pauser address can renounce the pausing right.\n   *\n   * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n   *\n   * @example\n   * const receipt = await kip37.renouncePauser({ from: '0x{address in hex}' })\n   *\n   * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n   * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n   *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n   */\n\n\n  async renouncePauser(sendParam = {}) {\n    const executableObj = this.methods.renouncePauser();\n    sendParam = await determineSendParams(executableObj, sendParam, this.options);\n    return executableObj.send(sendParam);\n  }\n\n}\n/**\n * The byte code of the KIP-37 token contract.\n *\n * @example\n * caver.kct.kip37.byteCode\n *\n * @static\n * @type {string}\n */\n\n\nKIP37.byteCode = kip37ByteCode;\n/**\n * The abi of the KIP-37 token contract.\n *\n * @example\n * caver.kct.kip37.abi\n *\n * @static\n * @type {Array.<object>}\n */\n\nKIP37.abi = kip37JsonInterface;\nmodule.exports = KIP37;","map":{"version":3,"sources":["/home/lorancecall/Projects/vuejs-tutorial/testpage/node_modules/caver-js/packages/caver-kct/src/kip37.js"],"names":["_","require","BigNumber","Contract","kip37JsonInterface","kip37ByteCode","determineSendParams","formatParamForUint256","validateDeployParameterForKIP37","interfaceIds","isAddress","toBuffer","isHexStrict","toHex","stripHexPrefix","leftPad","KIP13","KIP37","create","tokenAddress","abi","deploy","tokenInfo","sendOptions","wallet","uri","kip37","undefined","setWallet","isString","from","gas","value","data","arguments","send","detectInterface","contractAddress","constructor","Error","clone","options","address","cloned","jsonInterface","_wallet","detected","IKIP37","IKIP37Metadata","IKIP37Mintable","IKIP37Burnable","IKIP37Pausable","notSupportedMsg","_address","isSupported","isImplementedKIP13Interface","supportsInterface","Promise","all","Object","keys","map","interfaceName","e","interfaceId","methods","call","id","includes","tokenIdInHex","replace","totalSupply","balanceOf","account","balance","balanceOfBatch","accounts","ids","length","formattedTokenIds","i","push","balances","ret","bal","isApprovedForAll","owner","operator","paused","callObject","isPaused","isPauser","isMinter","initialSupply","sendParam","isObject","executableObj","setApprovalForAll","approved","safeTransferFrom","to","amount","Buffer","isBuffer","safeBatchTransferFrom","recipient","amounts","formattedTokenAmounts","mint","toList","values","isArray","formattedTokenValues","val","mintBatch","addMinter","renounceMinter","burn","burnBatch","pause","unpause","addPauser","renouncePauser","byteCode","module","exports"],"mappings":"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","sourcesContent":["/*\n    Copyright 2021 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst _ = require('lodash')\nconst BigNumber = require('bignumber.js')\n\nconst Contract = require('../../caver-contract')\nconst {\n    kip37JsonInterface,\n    kip37ByteCode,\n    determineSendParams,\n    formatParamForUint256,\n    validateDeployParameterForKIP37,\n    interfaceIds,\n} = require('./kctHelper')\nconst { isAddress, toBuffer, isHexStrict, toHex, stripHexPrefix, leftPad } = require('../../caver-utils')\nconst KIP13 = require('./kip13')\n\n/**\n * The KIP37 class that helps you easily handle a smart contract that implements KIP-37 as a JavaScript object on the Klaytn blockchain platform (Klaytn).\n * @hideconstructor\n * @class\n */\nclass KIP37 extends Contract {\n    /**\n     * Creates a new KIP37 instance with its bound methods and events.\n     *\n     * @example\n     * const kip37 = caver.kct.kip37.create('0x{address in hex}')\n     *\n     * @param {string} tokenAddress - The KIP-37 token contract address.\n     * @param {Array} [abi] - The Contract Application Binary Interface (ABI) of the KIP-37.\n     * @return {KIP37}\n     */\n    static create(tokenAddress, abi) {\n        return new KIP37(tokenAddress, abi)\n    }\n\n    /**\n     * An object that defines the parameters required to deploy the KIP-37 contract.\n     *\n     * @typedef {object} KIP37.KIP37DeployParams\n     * @property {string} uri - The URI for all token types, by relying on the {@link http://kips.klaytn.com/KIPs/kip-37#metadata|token type ID substitution mechanism}.\n     */\n    /**\n     * Deploys a KIP-37 token contract to Klaytn network.\n     *\n     * By default, it returns a KIP37 instance when the deployment is finished.\n     * If you define a custom function in the `contractDeployFormatter` field in {@link Contract.SendOptions|SendOptions}, you can control return type.\n     *\n     * @example\n     * const tokenInfo = { uri: 'uri string' }\n     *\n     * // Below example will use `caver.wallet`.\n     * const deployed = await caver.kct.kip37.deploy(tokenInfo, '0x{deployer address}')\n     *\n     * // Use sendOptions instead of deployer address.\n     * const sendOptions = { from: '0x{deployer address}', feeDelegation: true, feePayer: '0x{fee payer address}' }\n     * const deployed = await caver.kct.kip37.deploy(tokenInfo, sendOptions)\n     *\n     * // If you want to use your own wallet that implements the 'IWallet' interface, pass it into the last parameter.\n     * const deployed = await caver.kct.kip37.deploy(tokenInfo, '0x{deployer address}', wallet)\n     *\n     * @param {KIP37.KIP37DeployParams} tokenInfo The object that defines the uri to deploy.\n     * @param {Contract.SendOptions|string} sendOptions An object holding parameters that are required for sending a transaction.\n     * @param {IWallet} [wallet] The wallet instance to sign and send a transaction.\n     * @return {Promise<*>}\n     */\n    static deploy(tokenInfo, sendOptions, wallet) {\n        validateDeployParameterForKIP37(tokenInfo)\n\n        const { uri } = tokenInfo\n        const kip37 = new KIP37()\n        if (wallet !== undefined) kip37.setWallet(wallet)\n\n        // If sendOptions is string type, sendOptions means deployer's address\n        if (_.isString(sendOptions)) sendOptions = { from: sendOptions, gas: 7000000, value: 0 }\n        sendOptions.gas = sendOptions.gas !== undefined ? sendOptions.gas : 7000000\n\n        return kip37\n            .deploy({\n                data: kip37ByteCode,\n                arguments: [uri],\n            })\n            .send(sendOptions)\n    }\n\n    /**\n     * An object that defines the parameters required to deploy the KIP-37 contract.\n     *\n     * @typedef {object} KIP37.KIP37DetectedObject\n     * @property {boolean} IKIP37 - Whether to implement `IKIP37` interface.\n     * @property {boolean} IKIP37Metadata - Whether to implement `IKIP37Metadata` interface.\n     * @property {boolean} IKIP37Mintable - Whether to implement `IKIP37Mintable` interface.\n     * @property {boolean} IKIP37Burnable - Whether to implement `IKIP37Burnable` interface.\n     * @property {boolean} IKIP37Pausable - Whether to implement `IKIP37Pausable` interface.\n     */\n    /**\n     * Returns the information of the interface implemented by the token contract.\n     *\n     * @example\n     * const detected = await caver.kct.kip37.detectInterface('0x{address in hex}')\n     *\n     * @param {string} contractAddress The address of the KIP-37 token contract to detect.\n     * @return {Promise<KIP37.KIP37DetectedObject>}\n     */\n    static detectInterface(contractAddress) {\n        const kip37 = new KIP37(contractAddress)\n        return kip37.detectInterface()\n    }\n\n    constructor(tokenAddress, abi = kip37JsonInterface) {\n        if (tokenAddress) {\n            if (_.isString(tokenAddress)) {\n                if (!isAddress(tokenAddress)) throw new Error(`Invalid token address ${tokenAddress}`)\n            } else {\n                abi = tokenAddress\n                tokenAddress = undefined\n            }\n        }\n        super(abi, tokenAddress)\n        this.setWallet(KIP37.wallet)\n    }\n\n    /**\n     * Clones the current KIP37 instance.\n     *\n     * @example\n     * const cloned = kip37.clone()\n     * const cloned = kip37.clone('0x{new kip7 address}')\n     *\n     * @param {string} [tokenAddress] The address of the token contract.\n     * @return {KIP37}\n     */\n    clone(tokenAddress = this.options.address) {\n        const cloned = new this.constructor(tokenAddress, this.options.jsonInterface)\n        cloned.setWallet(this._wallet)\n        return cloned\n    }\n\n    /**\n     * Returns the information of the interface implemented by the token contract.\n     *\n     * @example\n     * const detected = await kip37.detectInterface()\n     *\n     * @return {Promise<KIP37.KIP37DetectedObject>}\n     */\n    async detectInterface() {\n        const detected = {\n            IKIP37: false,\n            IKIP37Metadata: false,\n            IKIP37Mintable: false,\n            IKIP37Burnable: false,\n            IKIP37Pausable: false,\n        }\n\n        const notSupportedMsg = `This contract does not support KIP-13.`\n        const contractAddress = this._address\n\n        try {\n            const isSupported = await KIP13.isImplementedKIP13Interface(contractAddress)\n            if (isSupported !== true) throw new Error(notSupportedMsg)\n\n            // Since there is an extension that has the same interface id even though it is a different KCT,\n            // it must be checked first whether the contract is a KIP-37 contract.\n            detected.IKIP37 = await this.supportsInterface(interfaceIds.kip37.IKIP37)\n            if (detected.IKIP37 === false) return detected\n\n            await Promise.all(\n                Object.keys(interfaceIds.kip37).map(async interfaceName => {\n                    if (interfaceIds.kip37[interfaceName] !== interfaceIds.kip37.IKIP37)\n                        detected[interfaceName] = await this.supportsInterface(interfaceIds.kip37[interfaceName])\n                })\n            )\n            return detected\n        } catch (e) {\n            throw new Error(notSupportedMsg)\n        }\n    }\n\n    /**\n     * Returns `true` if this contract implements the interface defined by `interfaceId`.\n     *\n     * @example\n     * const supported = await kip37.supportsInterface('0x6433ca1f')\n     *\n     * @param {string} interfaceId The interface id to check.\n     * @return {Promise<boolean>}\n     */\n    async supportsInterface(interfaceId) {\n        const isSupported = await this.methods.supportsInterface(interfaceId).call()\n        return isSupported\n    }\n\n    /**\n     * Returns distinct Uniform Resource Identifier (URI) of the given token.\n     * If the string {id} exists in any URI, this function will replace this with the actual token ID in hexadecimal form.\n     * Please refer to {@link http://kips.klaytn.com/KIPs/kip-37#metadata|KIP-34 Metadata}.\n     *\n     * @example\n     * const uri = await kip37.uri('0x0')\n     *\n     * @param {BigNumber|string|number} id The token id to get uri.\n     * @return {Promise<string>}\n     */\n    async uri(id) {\n        let uri = await this.methods.uri(formatParamForUint256(id)).call()\n\n        // Replace {id} to token id in hexadecimal form.\n        if (uri.includes('{id}')) {\n            let tokenIdInHex = stripHexPrefix(toHex(id))\n            tokenIdInHex = leftPad(tokenIdInHex, 64, '0')\n            uri = uri.replace('{id}', tokenIdInHex)\n        }\n        return uri\n    }\n\n    /**\n     * Returns the total token supply of the specific token.\n     *\n     * @example\n     * const totalSupply = await kip37.totalSupply(0)\n     *\n     * @param {BigNumber|string|number} id The token id to see the total supply.\n     * @return {Promise<BigNumber>}\n     */\n    async totalSupply(id) {\n        const totalSupply = await this.methods.totalSupply(formatParamForUint256(id)).call()\n        return new BigNumber(totalSupply)\n    }\n\n    /**\n     * Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * @example\n     * const balance = await kip37.balanceOf('0x{address in hex}', 0)\n     *\n     * @param {string} account The address of the account for which you want to see balance.\n     * @param {BigNumber|string|number} id The token id to see balance.\n     * @return {Promise<BigNumber>}\n     */\n    async balanceOf(account, id) {\n        const balance = await this.methods.balanceOf(account, formatParamForUint256(id)).call()\n        return new BigNumber(balance)\n    }\n\n    /**\n     * Returns the balance of multiple account/token pairs.\n     * `balanceOfBatch` is a batch operation of {@link balanceOf}, and the length of arrays with `accounts` and `ids` must be the same.\n     *\n     * @param {Array.<string>} accounts The address of the accounts for which you want to see balance.\n     * @param {Array.<BigNumber|string|number>} ids An array of ids of token you want to see balance.\n     * @return {Promise<Array.<BigNumber>>}\n     */\n    async balanceOfBatch(accounts, ids) {\n        if (ids.length !== accounts.length) throw new Error(`ids and accounts must have the same length.`)\n\n        const formattedTokenIds = []\n        for (let i = 0; i < ids.length; i++) {\n            formattedTokenIds.push(formatParamForUint256(ids[i]))\n        }\n\n        const balances = await this.methods.balanceOfBatch(accounts, formattedTokenIds).call()\n\n        const ret = []\n        for (const bal of balances) {\n            ret.push(new BigNumber(bal))\n        }\n\n        return ret\n    }\n\n    /**\n     * Queries the approval status of an operator for a given owner. Returns true if an operator is approved by a given owner.\n     *\n     * @example\n     * const isApprovedForAll = await kip37.isApprovedForAll('0x{address in hex}', '0x{address in hex}')\n     *\n     * @param {string} owner The address of the owner.\n     * @param {string} operator The address of the operator.\n     * @return {Promise<boolean>}\n     */\n    async isApprovedForAll(owner, operator) {\n        const isApprovedForAll = await this.methods.isApprovedForAll(owner, operator).call()\n        return isApprovedForAll\n    }\n\n    /**\n     * Returns whether or not the token contract's transaction (or specific token) is paused.\n     *\n     * If `id` parameter is not defined, return whether the token contract's transaction is paused.\n     * If `id` parameter is defined, return whether the specific token is paused.\n     *\n     * @example\n     * // without token id parameter\n     * const isPaused = await kip37.paused()\n     * // with token id parameter\n     * const isPaused = await kip37.paused(0)\n     *\n     * @param {BigNumber|string|number} [id] The token id to check wether paused or not. If this parameter is omitted, the `paused` function return whether the contract is in paused state.\n     * @return {Promise<boolean>}\n     */\n    async paused(id) {\n        const callObject = id !== undefined ? this.methods.paused(formatParamForUint256(id)) : this.methods.paused()\n        const isPaused = await callObject.call()\n        return isPaused\n    }\n\n    /**\n     * Returns `true` if the given account is a pauser who can suspend transferring tokens.\n     *\n     * @example\n     * const isPauser = await kip37.isPauser('0x{address in hex}')\n     *\n     * @param {string} account The address of the account to be checked for having the right to suspend transferring tokens.\n     * @return {Promise<boolean>}\n     */\n    async isPauser(account) {\n        const isPauser = await this.methods.isPauser(account).call()\n        return isPauser\n    }\n\n    /**\n     * Returns `true` if the given account is a minter who can issue new KIP37 tokens.\n     *\n     * @example\n     * const isMinter = await kip37.isMinter('0x{address in hex}')\n     *\n     * @param {string} account The address of the account to be checked for having the minting right.\n     * @return {Promise<boolean>}\n     */\n    async isMinter(account) {\n        const isMinter = await this.methods.isMinter(account).call()\n        return isMinter\n    }\n\n    /**\n     * create creates token and assigns them to account, increasing the total supply.\n     *\n     * @example\n     * // Send via a sendParam object with the from field given\n     * const receipt = await kip37.create(2, '1000000000000000000', { from: '0x{address in hex}' })\n     *\n     * @param {BigNumber|string|number} id The token id to create.\n     * @param {BigNumber|string|number} initialSupply The amount of tokens being minted.\n     * @param {string} [uri] The token URI of the created token.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async create(id, initialSupply, uri, sendParam = {}) {\n        if (uri && _.isObject(uri)) {\n            if (uri.gas !== undefined || uri.from !== undefined) {\n                if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`)\n                sendParam = uri\n                uri = ''\n            }\n        }\n\n        const executableObj = this.methods.create(formatParamForUint256(id), formatParamForUint256(initialSupply), uri)\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Approves the given operator, or disallow the given operator, to transfer all tokens of the owner.\n     * An operator is allowed to transfer all tokens of the sender on their behalf.\n     *\n     * @example\n     * const receipt = await kip37.setApprovalForAll('0x{address in hex}', true, { from: '0x{address in hex}' })\n     *\n     * @param {string} operator The address of an account to be approved/prohibited to transfer the owner's all tokens.\n     * @param {boolean} approved This operator will be approved if `true`. The operator will be disallowed if `false`.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async setApprovalForAll(operator, approved, sendParam = {}) {\n        const executableObj = this.methods.setApprovalForAll(operator, approved)\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Safely transfers the given `amount` tokens of specific token type `id` from `from` to the `recipient`.\n     *\n     * The address who was approved to send the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n     * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n     * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n     *\n     * If the `recipient` was a contract address, it should implement `IKIP37Receiver.onKIP37Received`. Otherwise, the transfer is reverted.\n     *\n     * @example\n     * const receipt = await kip37.safeTransferFrom('0x{address in hex}', '0x{address in hex}', 2, 10000, { from: '0x{address in hex}' })\n     *\n     * @param {string} from The address of the account that owns the token to be sent with allowance mechanism.\n     * @param {string} to The address of the account to receive the token.\n     * @param {BigNumber|string|number} id The token id to transfer.\n     * @param {BigNumber|string|number} amount The amount of token you want to transfer.\n     * @param {Buffer|string|number} [data] (optional) The data to send along with the call.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async safeTransferFrom(from, to, id, amount, data, sendParam = {}) {\n        if (data && _.isObject(data)) {\n            if (data.gas !== undefined || data.from !== undefined) {\n                if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`)\n                sendParam = data\n                data = Buffer.from('')\n            }\n        }\n\n        if (data && !_.isBuffer(data)) {\n            if (_.isString(data) && !isHexStrict(data)) data = toHex(data)\n            data = toBuffer(data)\n        }\n\n        const executableObj = this.methods.safeTransferFrom(from, to, formatParamForUint256(id), formatParamForUint256(amount), data)\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Safely batch transfers of multiple token ids and values from `from` to the `recipient`.\n     *\n     * The address who was approved to send the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n     * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n     * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n     *\n     * If the `recipient` was a contract address, it should implement `IKIP37Receiver.onKIP37Received`. Otherwise, the transfer is reverted.\n     *\n     * @example\n     * const receipt = await kip37.safeBatchTransferFrom('0x{address in hex}', '0x{address in hex}', [1, 2], [10, 1000], { from: '0x{address in hex}' })\n     *\n     * @param {string} from The address of the account that owns the token to be sent with allowance mechanism.\n     * @param {string} recipient The address of the account to receive the token.\n     * @param {Array.<BigNumber|string|number>} ids An array of the token ids to transfer.\n     * @param {Array.<BigNumber|string|number>} amounts An array of the token amounts you want to transfer.\n     * @param {Buffer|string|number} [data] (optional) The data to send along with the call.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async safeBatchTransferFrom(from, recipient, ids, amounts, data, sendParam = {}) {\n        if (data && _.isObject(data)) {\n            if (data.gas !== undefined || data.from !== undefined) {\n                if (Object.keys(sendParam).length > 0) throw new Error(`Invalid parameters`)\n                sendParam = data\n                data = Buffer.from('')\n            }\n        }\n\n        if (data && !_.isBuffer(data)) {\n            if (_.isString(data) && !isHexStrict(data)) data = toHex(data)\n            data = toBuffer(data)\n        }\n\n        if (ids.length !== amounts.length) throw new Error(`ids and amounts must have the same length.`)\n\n        const formattedTokenIds = []\n        const formattedTokenAmounts = []\n        for (let i = 0; i < ids.length; i++) {\n            formattedTokenIds.push(formatParamForUint256(ids[i]))\n            formattedTokenAmounts.push(formatParamForUint256(amounts[i]))\n        }\n\n        const executableObj = this.methods.safeBatchTransferFrom(from, recipient, formattedTokenIds, formattedTokenAmounts, data)\n\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Mints the token of the specific token type `id` and assigns the tokens according to the variables `to` and `value`.\n     * The mint function allows you to mint specific token to multiple accounts at once by passing arrays `to` to and `value` as parameters.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n     *\n     * @example\n     * const receipt = await kip37.mint('0x{address in hex}', 2, 1000, { from: '0x{address in hex}' })\n     *\n     * @param {string|Array.<string>} toList An address of the account or an array of addresses to which the minted token will be issued.\n     * @param {BigNumber|string|number} id The token id to mint.\n     * @param {BigNumber|string|number|Array.<BigNumber|string|number>} values The amount of token to be minted. If an array containing multiple addresses is delivered to `to` parameter, the value must be delivered in the form of an array.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async mint(toList, id, values, sendParam = {}) {\n        if (_.isArray(toList) !== _.isArray(values))\n            throw new Error(`If you want to minting a specific token to multiple accounts, both toList and values both must be arrays.`)\n\n        let executableObj\n        if (_.isArray(toList)) {\n            if (toList.length !== values.length) throw new Error(`toList and values must have the same length.`)\n\n            const formattedTokenValues = []\n            for (const val of values) {\n                formattedTokenValues.push(formatParamForUint256(val))\n            }\n\n            executableObj = this.methods.mint(formatParamForUint256(id), toList, formattedTokenValues)\n        } else {\n            executableObj = this.methods.mint(formatParamForUint256(id), toList, formatParamForUint256(values))\n        }\n\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Mints the multiple KIP-37 tokens of the specific token types `ids` in a batch and assigns the tokens according to the variables `to` and `values`.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n     *\n     * @example\n     * const receipt = await kip37.mintBatch('0x{address in hex}', [1, 2], [100, 200], { from: '0x{address in hex}' })\n     *\n     * @param {string} to An address of the account to which the minted tokens will be issued.\n     * @param {Array.<BigNumber|string|number>} ids An array of the token ids to mint.\n     * @param {Array.<BigNumber|string|number>} values An array of the token amounts to mint.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async mintBatch(to, ids, values, sendParam = {}) {\n        if (ids.length !== values.length) throw new Error(`ids and values must have the same length.`)\n\n        const formattedTokenIds = []\n        const formattedTokenValues = []\n        for (let i = 0; i < ids.length; i++) {\n            formattedTokenIds.push(formatParamForUint256(ids[i]))\n            formattedTokenValues.push(formatParamForUint256(values[i]))\n        }\n\n        const executableObj = this.methods.mintBatch(to, formattedTokenIds, formattedTokenValues)\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Adds an account as a minter, who are permitted to mint tokens.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n     *\n     * @example\n     * const receipt = await kip37.addMinter('0x{address in hex}', { from: '0x{address in hex}' })\n     *\n     * @param {string} account The address of the account to be added as a minter.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async addMinter(account, sendParam = {}) {\n        const executableObj = this.methods.addMinter(account)\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Renounces the right to mint tokens. Only a minter address can renounce the minting right.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a minter with MinterRole.\n     *\n     * @example\n     * const receipt = await kip37.renounceMinter({ from: '0x{address in hex}' })\n     *\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async renounceMinter(sendParam = {}) {\n        const executableObj = this.methods.renounceMinter()\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Burns specific KIP-37 tokens.\n     *\n     * The address who was approved to operate the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n     * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n     * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n     *\n     * @example\n     * const receipt = await kip37.burn('0x{address in hex}', 2, 10, { from: '0x{address in hex}' })\n     *\n     * @param {string} account The address of the account that owns the token to be destroyed.\n     * @param {BigNumber|string|number} id The id of token to be destroyed.\n     * @param {BigNumber|string|number} value The amount of token to be destroyed.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-7 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-7 abi.\n     */\n    async burn(account, id, value, sendParam = {}) {\n        const executableObj = this.methods.burn(account, formatParamForUint256(id), formatParamForUint256(value))\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Burns the multiple KIP-37 tokens.\n     *\n     * The address who was approved to operate the owner's token (the operator) or the token owner itself is expected to execute this token transferring transaction.\n     * Thus, the approved one or the token owner should be the sender of this transaction whose address must be given at `sendParam.from` or `kip37.options.from`.\n     * Without `sendParam.from` nor `kip37.options.from` being provided, an error would occur.\n     *\n     * @example\n     * const receipt = await kip37.burnBatch('0x{address in hex}', [1, 2], [100, 200], { from: '0x{address in hex}' })\n     *\n     * @param {string} account The address of the account that owns the token to be destroyed.\n     * @param {Array.<BigNumber|string|number>} ids An array of the token ids to burn.\n     * @param {Array.<BigNumber|string|number>} values An array of the token amounts to burn.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async burnBatch(account, ids, values, sendParam = {}) {\n        if (ids.length !== values.length) throw new Error(`ids and values must have the same length.`)\n\n        const formattedTokenIds = []\n        const formattedTokenValues = []\n        for (let i = 0; i < ids.length; i++) {\n            formattedTokenIds.push(formatParamForUint256(ids[i]))\n            formattedTokenValues.push(formatParamForUint256(values[i]))\n        }\n\n        const executableObj = this.methods.burnBatch(account, formattedTokenIds, formattedTokenValues)\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Suspends functions related to token operation.\n     * If `id` parameter is defined, pause the specific token. Otherwise pause the token contract.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n     *\n     * @example\n     * const receipt = await kip37.pause({ from: '0x{address in hex}' })\n     *\n     * @param {BigNumber|string|number} [id] The token id to pause. If this parameter is omitted, the `pause` function pause the token contract.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async pause(id, sendParam = {}) {\n        if (Object.keys(sendParam).length === 0 && _.isObject(id)) {\n            sendParam = id\n            id = undefined\n        }\n\n        const executableObj = id !== undefined ? this.methods.pause(formatParamForUint256(id)) : this.methods.pause()\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Resumes the paused contract or specific token.\n     * If `id` parameter is defined, unpause the specific token. Otherwise unpause the token contract.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n     *\n     * @example\n     * const receipt = await kip37.unpause({ from: '0x{address in hex}' })\n     *\n     * @param {BigNumber|string|number} [id] The token id to unpause. If this parameter is omitted, the `unpause` function unpause the token contract.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async unpause(id, sendParam = {}) {\n        if (Object.keys(sendParam).length === 0 && _.isObject(id)) {\n            sendParam = id\n            id = undefined\n        }\n\n        const executableObj = id !== undefined ? this.methods.unpause(formatParamForUint256(id)) : this.methods.unpause()\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Adds an account as a pauser that has the right to suspend the contract.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n     *\n     * @example\n     * const receipt = await kip37.addPauser('0x{address in hex}', { from: '0x{address in hex}' })\n     *\n     * @param {string} account The address of the account to be a new pauser.\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async addPauser(account, sendParam = {}) {\n        const executableObj = this.methods.addPauser(account)\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n\n    /**\n     * Renounces the right to pause the contract. Only a pauser address can renounce the pausing right.\n     *\n     * If `sendParam.from` or `kip37.options.from` were given, it should be a pauser with PauserRole.\n     *\n     * @example\n     * const receipt = await kip37.renouncePauser({ from: '0x{address in hex}' })\n     *\n     * @param {Contract.SendOptios} [sendParam] (optional) An object holding parameters that are required for sending a transaction.\n     * @return {Promise<object>} A receipt containing the execution result of the transaction for executing the KIP-37 token contract.\n     *                  In this receipt, instead of the logs property, there is an events property parsed by KIP-37 abi.\n     */\n    async renouncePauser(sendParam = {}) {\n        const executableObj = this.methods.renouncePauser()\n        sendParam = await determineSendParams(executableObj, sendParam, this.options)\n\n        return executableObj.send(sendParam)\n    }\n}\n\n/**\n * The byte code of the KIP-37 token contract.\n *\n * @example\n * caver.kct.kip37.byteCode\n *\n * @static\n * @type {string}\n */\nKIP37.byteCode = kip37ByteCode\n\n/**\n * The abi of the KIP-37 token contract.\n *\n * @example\n * caver.kct.kip37.abi\n *\n * @static\n * @type {Array.<object>}\n */\nKIP37.abi = kip37JsonInterface\n\nmodule.exports = KIP37\n"]},"metadata":{},"sourceType":"script"}