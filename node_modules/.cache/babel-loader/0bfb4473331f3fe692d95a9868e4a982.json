{"ast":null,"code":"'use strict';\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nconst Client = require('../../lib/core');\n\nconst toUrlSearchParams = require('../../lib/to-url-search-params');\n/**\n * @typedef {import('../../lib/core').ClientOptions} ClientOptions\n * @typedef {import('../..').HttpOptions} HttpOptions\n * @typedef {import('ipfs-core-types/src/basic').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/pin/remote/service').API} API\n * @typedef {import('ipfs-core-types/src/pin/remote/service').Credentials} Credentials\n * @typedef {import('ipfs-core-types/src/pin/remote/service').RemotePinService} RemotePinService\n * @typedef {import('ipfs-core-types/src/pin/remote/service').RemotePinServiceWithStat} RemotePinServiceWithStat\n * @implements {API}\n */\n\n\nclass Service {\n  /**\n   * @param {ClientOptions} options\n   */\n  constructor(options) {\n    /** @private */\n    this.client = new Client(options);\n  }\n  /**\n   * @param {Client} client\n   * @param {string} name\n   * @param {Credentials & AbortOptions & HttpOptions} options\n   */\n\n\n  static async add(client, name, options) {\n    const {\n      endpoint,\n      key,\n      headers,\n      timeout,\n      signal\n    } = options;\n    await client.post('pin/remote/service/add', {\n      timeout,\n      signal,\n      searchParams: toUrlSearchParams({\n        arg: [name, Service.encodeEndpoint(endpoint), key]\n      }),\n      headers\n    });\n  }\n  /**\n   * @param {URL} url\n   */\n\n\n  static encodeEndpoint(url) {\n    const href = String(url);\n\n    if (href === 'undefined') {\n      throw Error('endpoint is required');\n    } // Workaround trailing `/` issue in go-ipfs\n    // @see https://github.com/ipfs/go-ipfs/issues/7826\n\n\n    return href[href.length - 1] === '/' ? href.slice(0, -1) : href;\n  }\n  /**\n   * @param {Client} client\n   * @param {string} name\n   * @param {AbortOptions & HttpOptions} [options]\n   */\n\n\n  static async rm(client, name, {\n    timeout,\n    signal,\n    headers\n  } = {}) {\n    await client.post('pin/remote/service/rm', {\n      timeout,\n      signal,\n      headers,\n      searchParams: toUrlSearchParams({\n        arg: name\n      })\n    });\n  }\n  /**\n   * @template {true} Stat\n   * @param {Client} client\n   * @param {{ stat?: Stat } & AbortOptions & HttpOptions} [options]\n   */\n\n\n  static async ls(client, {\n    stat,\n    timeout,\n    signal,\n    headers\n  } = {}) {\n    const response = await client.post('pin/remote/service/ls', {\n      searchParams: stat === true ? toUrlSearchParams({\n        stat\n      }) : undefined,\n      timeout,\n      signal,\n      headers\n    });\n    /** @type {{RemoteServices: Object[]}} */\n\n    const {\n      RemoteServices\n    } = await response.json();\n    /** @type {Stat extends true ? RemotePinServiceWithStat[] : RemotePinService []} */\n\n    return RemoteServices.map(Service.decodeRemoteService);\n  }\n  /**\n   * @param {Object} json\n   * @returns {RemotePinServiceWithStat}\n   */\n\n\n  static decodeRemoteService(json) {\n    return {\n      service: json.Service,\n      endpoint: new URL(json.ApiEndpoint),\n      ...(json.Stat && {\n        stat: Service.decodeStat(json.Stat)\n      })\n    };\n  }\n  /**\n   * @param {Object} json\n   * @returns {import('ipfs-core-types/src/pin/remote/service').Stat}\n   */\n\n\n  static decodeStat(json) {\n    switch (json.Status) {\n      case 'valid':\n        {\n          const {\n            Pinning,\n            Pinned,\n            Queued,\n            Failed\n          } = json.PinCount;\n          return {\n            status: 'valid',\n            pinCount: {\n              queued: Queued,\n              pinning: Pinning,\n              pinned: Pinned,\n              failed: Failed\n            }\n          };\n        }\n\n      case 'invalid':\n        {\n          return {\n            status: 'invalid'\n          };\n        }\n\n      default:\n        {\n          return {\n            status: json.Status\n          };\n        }\n    }\n  }\n  /**\n   * Registers remote pinning service with a given name. Errors if service\n   * with the given name is already registered.\n   *\n   * @param {string} name\n   * @param {Credentials & AbortOptions & HttpOptions} options\n   */\n\n\n  add(name, options) {\n    return Service.add(this.client, name, options);\n  }\n  /**\n   * Unregisteres remote pinning service with a given name. If service with such\n   * name isn't registerede this is a noop.\n   *\n   * @param {string} name\n   * @param {AbortOptions & HttpOptions} [options]\n   */\n\n\n  rm(name, options) {\n    return Service.rm(this.client, name, options);\n  }\n  /**\n   * List registered remote pinning services.\n   *\n   * @param {{ stat?: true } & AbortOptions & HttpOptions} [options]\n   */\n\n\n  ls(options) {\n    return Service.ls(this.client, options);\n  }\n\n}\n\nmodule.exports = Service;","map":{"version":3,"sources":["/home/lorancecall/Projects/vuejs-tutorial/testpage/node_modules/ipfs-http-client/src/pin/remote/service.js"],"names":["Client","require","toUrlSearchParams","Service","constructor","options","client","add","name","endpoint","key","headers","timeout","signal","post","searchParams","arg","encodeEndpoint","url","href","String","Error","length","slice","rm","ls","stat","response","undefined","RemoteServices","json","map","decodeRemoteService","service","URL","ApiEndpoint","Stat","decodeStat","Status","Pinning","Pinned","Queued","Failed","PinCount","status","pinCount","queued","pinning","pinned","failed","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nconst Client = require('../../lib/core')\nconst toUrlSearchParams = require('../../lib/to-url-search-params')\n\n/**\n * @typedef {import('../../lib/core').ClientOptions} ClientOptions\n * @typedef {import('../..').HttpOptions} HttpOptions\n * @typedef {import('ipfs-core-types/src/basic').AbortOptions} AbortOptions\n * @typedef {import('ipfs-core-types/src/pin/remote/service').API} API\n * @typedef {import('ipfs-core-types/src/pin/remote/service').Credentials} Credentials\n * @typedef {import('ipfs-core-types/src/pin/remote/service').RemotePinService} RemotePinService\n * @typedef {import('ipfs-core-types/src/pin/remote/service').RemotePinServiceWithStat} RemotePinServiceWithStat\n * @implements {API}\n */\nclass Service {\n  /**\n   * @param {ClientOptions} options\n   */\n  constructor (options) {\n    /** @private */\n    this.client = new Client(options)\n  }\n\n  /**\n   * @param {Client} client\n   * @param {string} name\n   * @param {Credentials & AbortOptions & HttpOptions} options\n   */\n  static async add (client, name, options) {\n    const { endpoint, key, headers, timeout, signal } = options\n    await client.post('pin/remote/service/add', {\n      timeout,\n      signal,\n      searchParams: toUrlSearchParams({\n        arg: [name, Service.encodeEndpoint(endpoint), key]\n      }),\n      headers\n    })\n  }\n\n  /**\n   * @param {URL} url\n   */\n  static encodeEndpoint (url) {\n    const href = String(url)\n    if (href === 'undefined') {\n      throw Error('endpoint is required')\n    }\n    // Workaround trailing `/` issue in go-ipfs\n    // @see https://github.com/ipfs/go-ipfs/issues/7826\n    return href[href.length - 1] === '/' ? href.slice(0, -1) : href\n  }\n\n  /**\n   * @param {Client} client\n   * @param {string} name\n   * @param {AbortOptions & HttpOptions} [options]\n   */\n  static async rm (client, name, { timeout, signal, headers } = {}) {\n    await client.post('pin/remote/service/rm', {\n      timeout,\n      signal,\n      headers,\n      searchParams: toUrlSearchParams({\n        arg: name\n      })\n    })\n  }\n\n  /**\n   * @template {true} Stat\n   * @param {Client} client\n   * @param {{ stat?: Stat } & AbortOptions & HttpOptions} [options]\n   */\n  static async ls (client, { stat, timeout, signal, headers } = {}) {\n    const response = await client.post('pin/remote/service/ls', {\n      searchParams: stat === true ? toUrlSearchParams({ stat }) : undefined,\n      timeout,\n      signal,\n      headers\n    })\n\n    /** @type {{RemoteServices: Object[]}} */\n    const { RemoteServices } = await response.json()\n\n    /** @type {Stat extends true ? RemotePinServiceWithStat[] : RemotePinService []} */\n    return (RemoteServices.map(Service.decodeRemoteService))\n  }\n\n  /**\n   * @param {Object} json\n   * @returns {RemotePinServiceWithStat}\n   */\n  static decodeRemoteService (json) {\n    return {\n      service: json.Service,\n      endpoint: new URL(json.ApiEndpoint),\n      ...(json.Stat && { stat: Service.decodeStat(json.Stat) })\n    }\n  }\n\n  /**\n   * @param {Object} json\n   * @returns {import('ipfs-core-types/src/pin/remote/service').Stat}\n   */\n  static decodeStat (json) {\n    switch (json.Status) {\n      case 'valid': {\n        const { Pinning, Pinned, Queued, Failed } = json.PinCount\n        return {\n          status: 'valid',\n          pinCount: {\n            queued: Queued,\n            pinning: Pinning,\n            pinned: Pinned,\n            failed: Failed\n          }\n        }\n      }\n      case 'invalid': {\n        return { status: 'invalid' }\n      }\n      default: {\n        return { status: json.Status }\n      }\n    }\n  }\n\n  /**\n   * Registers remote pinning service with a given name. Errors if service\n   * with the given name is already registered.\n   *\n   * @param {string} name\n   * @param {Credentials & AbortOptions & HttpOptions} options\n   */\n  add (name, options) {\n    return Service.add(this.client, name, options)\n  }\n\n  /**\n   * Unregisteres remote pinning service with a given name. If service with such\n   * name isn't registerede this is a noop.\n   *\n   * @param {string} name\n   * @param {AbortOptions & HttpOptions} [options]\n   */\n  rm (name, options) {\n    return Service.rm(this.client, name, options)\n  }\n\n  /**\n   * List registered remote pinning services.\n   *\n   * @param {{ stat?: true } & AbortOptions & HttpOptions} [options]\n   */\n  ls (options) {\n    return Service.ls(this.client, options)\n  }\n}\n\nmodule.exports = Service\n"]},"metadata":{},"sourceType":"script"}